\section{A3-E}\label{sec:A3-E}

%\begin{figure}[tbp]
%	\includegraphics[width=0.92\textwidth]{figs/A3-E-process}
%%	\setlength{\belowcaptionskip}{-10pt}
%	\caption{A3-E overview. A3-E's activities are carried out by a \textit{domain manager} and a \textit{mobile middleware}, and coordinate through incoming ($\rightarrow$) and outgoing ($\leftarrow$) asynchronous events.}
%	\label{fig:A3-E-process}
%\end{figure}

\begin{figure}[tbp]
	\includegraphics[width=0.85\textwidth]{figs/A3-E-process}
	%	\setlength{\belowcaptionskip}{-10pt}
	\caption{A3-E overview. A3-E's activities --- (AW)areness, (AQ)uisition, (AL)location, (E)ngagement --- are carried out by a \textit{domain manager} and a \textit{mobile middleware}, and coordinate through asynchronous events depicted by and identified as follows: \textit{domain identification}~(DI), \textit{client identification}~(CI), \textit{client arrived}~(CA),\textit{client left}~(CL),\textit{$\mu$-service identified}~($\mu$I), \textit{$\mu$-service acquired}~($\mu$AQ), \textit{$\mu$-service allocated}~($\mu$AL), \textit{$\mu$-service (deallocated}~($\mu$DA), \textit{domain found}~(DF), \textit{domain lost}~(DL), \textit{domain ready}~(DR), \textit{domain changed}~(DS), \textit{execution time}~($\Delta$EX), \textit{$\mu$-service request}~($\mu$RQ), \textit{$\mu$-service response}~($\mu$RS), \textit{C-Request}~(C-RQ).}
	\label{fig:A3-E-process}
\end{figure}

%First and foremost, A3-E's main objective is to enable the efficient and scalable placement of $\mu$-services along the continuum. In A3-E, clients and providers autonomously interact and decide for the placement of services according to the context. Moreover,  

To realize the mobile-edge-cloud continuum, we propose A3-E, a model supporting the self-management of continuum $\mu$-service life-cycles. A3-E inherits its name from its four main activities -- namely, \textit{(\textbf{A})wareness, (\textbf{A})cquisition, (\textbf{A})llocation, and (\textbf{E})ngagement}. 

A3-E targets 
the efficient and scalable placement of $\mu$-services along the continuum and the satisfaction of application requirements such as maximum service latency, battery consumption, and availability. 
To achieve it, clients and heterogeneous domains take part in the automated and opportunistic decision of which continuum resources --- among those of mobile, edge, and cloud --- should be employed in provisioning each of the $\mu$-service required by continuum applications. 

%A3-E targets 
%%the materialization of the continuum by means of an
%the efficient and scalable placement of $\mu$-services along the continuum. 
%To achieve it, clients and heterogeneous \textit{mobile, edge, and cloud} domains take part in the \textit{automated} and \textit{decentralized} decision of which continuum resources should be employed in provisioning each of the $\mu$-services required by continuum applications.% according to the context of operation.


%A3-E exploits the FaaS paradigm and propose additional mechanisms for 

Figure~\ref{fig:A3-E-process} illustrates each activity in A3-E. 
Activities are refined by procedures that coordinate through asynchronous events and are carried out by a \textit{domain manager} and by a \textit{mobile middleware}. 
%Activities from both sides are coordinated through signals and events. 
To address the intrinsic heterogeneity of the continuum, A3-E is flexible with respect to how each of its activities is actually implemented. 
%For each phase, the main activities of a \textit{domain} and a \textit{client} are depicted along with their mutual relative state at the moment the phase starts: for a domain, a service state ranges from \textit{Free} to \textit{Allocated}, whilst a domain state ranges from \textit{Away} to \textit{Selected} for a client. 
%More precisely, Fig.~\ref{fig:A3-E-process} refers to the activities and states (in parenthesis) of a single client-domain interaction.

%Next, we detail each main activity in A3-E, starting from the most general one, i.e., the one that applies to all types of client-domain interaction, and moving towards the more specific ones.


%\subsection{A3-E Process: Phases}\label{sec:A3-E-process}

%Next, the four A3-E phases are further described and mapped to the requirements elicited in  Section~\ref{sec:requirements}. Later on, other possible instances of the A3-E model are correlated with scenarios of the compute continuum.


\subsection{Awareness}\label{sec:A3-E-awareness}

%From the provider's viewpoint, the main purpose of Awareness is to enable domains to opportunistically and pro-actively initialize the Acquisition and Allocation activities. %, based on the awareness of devices in a domain's coverage area. 
%In turn, clients benefit from Awareness with the dynamic discovery and profiling of domains that can provide the $\mu$-services they need.

%A3-E's Awareness models (i) the discovery of domains and (ii) the discovery of continuum applications in one of its domains' area of coverage, indicating the imminent need for specific $\mu$-services. 




The latency of continuum $\mu$-services can be decomposed into three parts: \textit{acquisition delay} ($\Delta AQ$), \textit{allocation delay} ($\Delta AL$), and \textit{execution delay} ($\Delta E$). FaaS platforms like AWS Lambda~\cite{AWSLambda}
%~\footnote{https://docs.aws.amazon.com/lambda/latest/dg/running-lambda-code.html}
and OpenWhisk~\cite{OpenWhisk} adopt a \textit{cold start} policy in which $\mu$-services are allocated after their first call following a period of idleness. This latency, however, may be disruptive for some applications. 
%To satisfy the maximum accepted latency of provided $\mu$-services, a \textit{domain manager} mitigates each component as follows: 

%In comparison, %the proposed mutual client-provider awareness 
A3-E's Awareness has two benefits: (i) it alleviates $\Delta AL$ (cold starts) by pro-actively allocating $\mu$-services just before they are needed; and (ii) it reduces $\Delta AQ$ and enables $\mu$-service acquisition to be opportunistic (i.e., on demand) by triggering the download and installation of new $\mu$-services as soon as the client becomes active in a specific domain (e.g., by starting the application or by entering an edge domain's area).

%TODO [Danilo] this kind of detail fits better in the implementation, doesn't it?
While cloud domains are not likely to change, and may be set-up statically by clients,% to realize this activity
edge domains must advertise their existence (\textit{domain identification}) using protocols that are compatible with its network infrastructure: for instance, through IP broadcasting in local-edge, and through Evolved Multimedia Broadcast/Multicast Service (eMBMS) in mobile-edge~\cite{lecompte2012evolved,etsimec16:03}. 
In particular, edge domains exploit locality by triggering a \textit{client left} event once mobile devices leave its coverage area, whilst cloud domains rely on adjustable \textit{timeout}.% for triggering this event.




%Throughout Awareness, the domain manager handles the following event:

%{\small
%\begin{itemize}
%	
%	\item \textbf{Client identified:} triggered when a new client enters the domain's coverage area. The manager must react with the triggering of a \textit{client arrived} and \textit{$\mu$-service identified} events for each $\mu$-service required by the client.
%	
%\end{itemize}
%}%

From the client's perspective, Awareness corresponds to the discovery of domains (source of \textit{domain found} and \textit{domain lost} events) and the advertisement of required $\mu$-services through a \textit{client identification} signal containing their metadata (name, repository url), upon which the domain manager triggers both \textit{client arrived} and \textit{$\mu$-service identified} events.% for each required $\mu$-service. 

To realize this activity, special purpose HTTP endpoints can be used for cloud domains; protocols from local area networks (e.g., UDP, IP multicast) are used for local-edge domains; eMBMS protocols (e.g., FLUTE~\cite{lecompte2012evolved}) which are carried over traditional UDP and IP multicast toward end-user devices, are used for mobile-edge domains; and system-level signals (e.g., broadcast intents in Android platforms) are used by mobile domains.

%[Danilo] 2ndR: this paragraph is poor
%In our running example, the mobile-edge and local-edge domains must advertise their existence to our user's device, which in turn identifies the AR and Image Editing applications. The same holds for the hotel's local-edge domain and the MG application. %In all cases, cloud and edge domains can employ Awareness to opportunistically fetch, install, and allocate instances of required $\mu$-services.


%The mobile middleware, in turn, realizes Awareness with the discovery of cloud and edge domains. In particular, 
%During Awareness, the mobile middleware handles the following event:
%
%{\small
%\begin{itemize}
%	
%	\item \textbf{Domain identified:} triggered when a domain is found. The middleware must react with the triggering of a \textit{domain found} event and a \textit{client identification} signal to the domain manager.
%	
%\end{itemize}
%}%

%To implement Awareness, 

%It copes with the need for efficiency and scalability of finely distributed edge domains by allowing acquisition and/or allocation of services to happen just in time, i.e., just before the client application needs them.
%and enables not only functions to be allocated, but also acquired in an opportunistic fashion.
%The benefit lies in the anticipation of (opportunistic) services setup with respect to the arrival of the first service request, i.e., in the mitigation of service setup delay (also known as cold start). Since cloud domains cover a large area, the later do not employ the awareness phase. Needless to say, mobile domains do not require awareness for sharing the same platform with client applications.

%TODO [Danilo] Commented-out in favor of a more abstract description in terms of events, as broadcasting is something local-edge specific
%The DSM achieves this by broadcasting its existence and by waiting for clients to pass along their requirements. In our running example this occurs when the user's domestic local-edge server becomes aware of the new mobile game that the user had just installed. 
%%nd the discovery of client applications along with their requirements (i.e., services). The later are passed to the following phase of acquisition.
%%then receive all client application requirements (i.e., services) as soon as the client's mobile device enters the domain's coverage area, and then pro-actively starting acquisition and allocation. 
%%For example, in the real-time translation application previously introduced, the service setup delay was mitigated by having the acquisition of the data and codebase composing the service to start as soon as the user entered the edge domain's coverage area.
%%For example, the setup of services required by the mobile multiplayer game application by the user's local-edge server follows the awareness of a new application.
%From the client's perspective, the awareness phase models the discovery of domains, and corresponding $\mu$-services, whose network addresses are not previously known. In particular, it tackles edge domains that are integrated with the local network infrastructures of buildings and public spaces. This modality contrasts with cloud which are accessed through DNS and traffic managers. Needless to say, the awareness phase is not considered by mobile domains. The CSM intercepts the provider's broadcast messages, and reacts by sending back its application requirements. This process should happen once, and in a timely fashion, upon connection to new networks to mitigate battery consumption. As an example, the local-edge server in our user's home is discovered when her mobile device connects to her domestic Wi-Fi network. 


%Once the domain is ready, this domain becomes an alternative for the provisioning of services required by the many applications (e.g., the mobile multiplayer game) hosted by the user's smartphone, tablet, and/or other of his IoT gadgets. 


%Finally, the Awareness phase has the following purposes: 1) to enable domains to pro-actively initialize the acquisition and allocation phases based on its awareness of applications whose hosting devices happens to be in the domain coverage area (Req.~\textbf{R2.3}); and 2) to enable clients to discover the address of local domains (Req.~\textbf{R2.2}).

%From the domains perspective, the awareness of clients presence in their coverage area allows a proactive download and installation of services artifacts (acquisition phase) and/or the allocation of services (allocation phase) potentially before a first request to that service arrives, alleviating the delay introduced by services setup.  From the clients perspective, the awareness phase increases the range of alternatives from the continuum that can be used to satisfy their requirements.

%Such behavior allows that are opportunistically acquired and/or allocated to mitigate their setup delay by triggering these phases upon awareness of client(s) in their coverage area.

%From the domain-side, the lack of awareness of clients in the domain coverage area prevents triggering the acquisition and subsequently allocation phases based on this event. From the client-side, the lack of awareness from surrounding domains prevents them to make the decision of which domains to use. In the later case, clients must rely on external components to reach servers (e.g., traffic managers and DNS servers).

\subsection{Acquisition}\label{sec:A3-E-acquisition}

A3-E's \textit{Acquisition} models the automated download and installation of continuum $\mu$-service artifacts, and the confirmation of the domain's capability in providing that $\mu$-service. Its ultimate goal is to mitigate the use of domain resources before the $\mu$-service is actually needed, while also facilitating IT operations (Ops) for developers and administrators. 

Ops mitigation is particularly important in (finely distributed) edge domains, since the manual administration of a large number of $\mu$-services can prove cumbersome and expensive. Nevertheless, this can also prove useful for cloud domains. Indeed, to the best of our knowledge, current FaaS platforms only support uploading (pushing) functions through public interfaces. 

Acquisition is autonomously managed, therefore it allows $\mu$-services to be downloaded 
%(e.g., pulled from a repository) 
and installed on demand. A domain manager fetches the artifacts (e.g., compiled classes and dependencies) from a repository upon the arrival of a \textit{$\mu$-service identified} event. Note that mobile domains are exempt of performing Acquisition as local $\mu$-services are assumed to be downloaded and installed along with the client application and the mobile middleware. 

% In addition to function sources, artifacts may comprise data and libraries needed by the service.

%Throughout Acquisition, the domain manager handles the following event:
%
%{\small
%\begin{itemize}
%	
%	\item \textbf{$\mu$-service identified:} indicates the request for deployment of a new $\mu$-service. The manager must proceed with the download and installation of the $\mu$-service, followed by the triggering of a \textit{service acquired} (or \textit{denied}) signal/event according to the activity outcome.
%	%its capability in providing that $\mu$-service.
%	
%	%\item \textbf{Client arrived:} triggered when a new client entered the domain's coverage area. The manager must react with 
%	
%\end{itemize}
%}%

%In this phase, the domain manager receives a set of application requirements from the client's CSM, namely the list of $\mu$-services and the URL of their repositories. The desired $\mu$-service artifacts are then downloaded and installed, at which point the DSM informs the client whether the $\mu$-services can be considered ``acquired'' or not. 
%Throughout the $\mu$-services' life-cycles, the DSM periodically checks for new versions of acquired services and updates them accordingly. 
%As an example, the services consumed by both AR applications introduced early can be autonomously acquired on demand by the local-edge servers in the user's office and home, preventing the company and the user to perform such operation. 
%In case the service has already been acquired or as the acquisition finishes, clients should add that domain to their list of available domains. 

From the client's perspective, Acquisition corresponds to the confirmation (or denial) of a domain's capability in providing the $\mu$-services required by the application. After a \textit{domain found} event, the mobile middleware listens for a \textit{$\mu$-service acquired} signal --- to be handled with the update of a list of capable domains and the subsequent triggering of a \textit{domain confirmed} (or \textit{denied}) event.

In our running example, the assets composing the $\mu$-services from the AR, Image Editing, and MG applications are once fetched and installed by the two local-edge domains upon arrival of a first \textit{$\mu$-service identified} event. While this is achieved, the applications momentarily continue to rely on their own mobile domain, or on any other domain on which $\mu$-services have already been acquired and allocated due to a previous client-domain interaction (e.g., the mobile-edge domains in our example skip Acquisition of AR artifacts due to previous contact with tourist devices).

%
%During this activity, the mobile middleware deals with the following events:
%
%{\small
%\begin{itemize}
%	
%	\item \textbf{Domain found:} indicates a potential domain for a $\mu$-service has been found. The middleware must proceed with the \textit{$\mu$-service identification} signal (if the domain is new) followed by the triggering of a \textit{domain confirmed} event.	
%	
%	\item \textbf{$\mu$-service acquired:} indicates a successful acquisition of a previously identified $\mu$-service. The middleware must react with the triggering of a \textit{domain confirmed} event.
%	
%	\item \textbf{$\mu$-service denied:} indicates the failure in acquiring and/or deploying a $\mu$-service. The middleware must proceed with the blacklisting of that domain. 
%	
%\end{itemize}
%}%


 %follow the identification of the domain's capability in providing the requested service. This phase is realized by the CSM with the following sub-process: the CSM should expect a confirmation from the DSM regarding its compliance in providing the service required by the application. Once confirmed, the CSM adds that domain to a list of available domains used by the client-side allocation phase. 

%As an example, a real-time translation application from/to streams of different spoken languages require services with low-latency. The translation can either rely on local services provided by the mobile domain (zero network latency) or on remote services provided by the edge domain (low network latency). Given the battery constraints of the mobile device, edge services are preferred. Instead of having all artifacts pre-installed, the edge's DSM acquires the data and codebase from a repository informed by the CSM upon detection of the user in its coverage area. The setup process takes no more than a minute, during which local services were consumed. Once the setup is ready, the application can start streaming captured conversations to edge-based services, which in turn reply with a translated audio stream.

%From the domain-side, the lack of acquisition implies that service assets must be previously made available. Nonetheless, the preliminary acquisition of a large number of assets is limited by the domain storage capability. 

%Conversely, the automated and opportunistic acquisition of service assets improves storage efficiency with the cost of a setup time $\Delta_{AQ}$. For instance, domains that become aware of clients' requirements may pro-actively start the acquisition phase and become ready for allocation before the first service request arrives.

%otherwise, domains must rely on the detection of a first service request or some other triggering condition to start the acquisition phase and, after setup time $\Delta_A$, become ready for allocation. 



\subsection{Allocation}\label{sec:A3-E-allocation}

%\begin{figure}[thbp]
%	\centering
%	\captionsetup[subfigure]{width=0.4\textwidth}	
%	\null\hfill
%	\subfloat[Domain $\mu$-services allocation control loop; domains must monitor the QoS of deployed $\mu$-services and adapt its allocation scheme to prevent SLA violations.\label{fig:service-allocation-loop}]{ \includegraphics[width=0.4\textwidth]{figs/service-allocation-loop}}
%	\captionsetup[subfigure]{width=0.4\textwidth}	
%	\hfill
%	\subfloat[Per $\mu$-service domain selection control loop; clients monitor $\mu$-services from available domains and select the one that best satisfies its requirements.\label{fig:domain-selection-loop}] {\includegraphics[width=0.4\textwidth]{figs/domain-selection-loop}}
%	\hfill\null
%	\caption{Self-management loops for domain-side $\mu$-services allocation and client-side domain selection}\label{fig:allocation-loops}
%\end{figure}


\textit{Allocation} models the deployment of continuum $\mu$-services on a pool of resources provided by the domain. It also captures the client-side selection of domains for each of the $\mu$-services employed by the application.

%From the domain's perspective, the allocation phase models the placement of $\mu$-services on the domain's resources, i.e., on its pool of servers, virtual machines, and containers. At the beginning of this phase, $\mu$-service artifacts have been \textit{acquired} by the domain, and the client has been \textit{notified} of this.

The scope of the provider-side Allocation is limited by its domain boundaries. Cloud domains allocate $\mu$-service instances to containers in resourceful datacenters covering a large area. On the other hand, edge domains rely on containers from one or more (virtual) machines serving an office or a building (local-edge) or a 5G base station area (mobile-edge). Finally, the allocation of $\mu$-services into mobile domain resources is platform specific (e.g., Android service life-cycle).

%pre-allocated and no allocation is needed.

%In this paper, we do not consider inter-domain cooperation (e.g., placement among different domains).

Existing FaaS platforms handle Allocation with on demand instantiation of containers after a first request, which may be kept \textit{warm} before being deallocated after a period of idleness~\cite{AWSLambda, OpenWhisk}. A3-E generalizes this mechanism as a self-management loop~\cite{kephart2003vision}
in which $\mu$-service instances are allocated to cloud and edge domain resources to guarantee that service latency and availability of each provided $\mu$-service are in-line with the desired SLA. 

%To better express this problem, let's consider the set of $\mu$-services $S = \{s_j \mid j = 0,1,...,J\}$.
%%In turn, $F_i = \{f_{i,j}\}_j$ defines the set of instances of $s_i$, with $0 \le j \le n_i$.
%%Instances for each $\mu$-service are defined by the set $F_i = \{f_{i,j}\}_j$, with $0 \le j \le n_i$.
%Vector $\bar{c} = (c_1, ..., c_J)$ holds the number of instances for all $\mu$-services. Each instance is bound to a container; resources allocated to each container 
%%Each $s_j \in S$ has a corresponding set of instances $F_j = \{f_{j,i} \mid i = 0,1,...,I_j\}$, where each instance is bound to a container. 
%(e.g., CPU and memory) are considered fixed and equal for all $\mu$-services, coherently to the architecture of FaaS frameworks such as OpenWhisk~\cite{OpenWhisk}.
%
%Now let's assume that each provided $\mu$-service $s_i \in S$ is bound to an SLA specifying its \textit{maximum accepted service latency} $\Delta_j$ 
%as well as the minimum/maximum number of service instances $Kmin_{j}/Kmax_{j}$. %, and a relative priority $p_i$. 
%Given the fluctuations in the workload and the response time $\tau_j$ (comprising both \textit{queue time} and \textit{service time}) of each $\mu$-service $s_j \in S$, the aim of a \textit{domain manager} is to find the minimum $c_j$ for each $\mu$-service so that, $\forall s_j \in S,\ \tau_j \le \Delta_j\ \wedge\ Kmin_j \le c_j \le Kmax_j$. 

To achieve this goal, the self-management \textit{monitor} ($M$ in Fig.~\ref{fig:A3-E-process}) measures the number of $\mu$-service invocations  and their execution times ($QoS$ in Fig.~\ref{fig:A3-E-process}) and it detects \textit{client arrived} and \textit{client left} events from Awareness (respectively $CA$ and $CL$ in Fig.~\ref{fig:A3-E-process}). %Moreover, it monitors CPU and memory utilization from the domain's pool of resources.
The \textit{analyzer} ($A$ in Fig.~\ref{fig:A3-E-process}) aggregates the monitored data over a predefined time window and it computes the \textit{arrival rate} ($\alpha_j$), the \textit{response time} ($\tau_j$), as well as the \textit{number of clients}. 

By reasoning on this analysis, the \textit{planner} ($P$ in Fig.~\ref{fig:A3-E-process}) calculates the number of instances $c_j$ for each $s_j \in S$ so that $\forall s_j \in S,\ \tau_j \le \Delta_j\ \wedge\ Kmin_j \le c_j \le Kmax_j$. To mitigate \textit{cold start} ($\Delta AL$), the planner reacts to a \textit{client arrived} event by anticipating container allocation if resources are available at that loop iteration; and by keeping containers allocated (\textit{warm}) after each \textit{$\mu$-service request}. Given the resource limitations of edge domains, contention between different $\mu$-services may exist. Thus, \textit{planner} is also in charge of managing such situations by discriminating applications by priority. If we go back to our running example, critical applications should have a higher priority with respect to others, like the AR for tourists. In such cases, some $\mu$-services might become unavailable or available with an higher response time. Finally, the \textit{executor} ($E$ in Fig.~\ref{fig:A3-E-process}) carries out the new allocation scheme by means of commands to the container platform (e.g., Docker).


%Additionally, the mobile device may loose connectivity, preventing communication with edge and cloud domains. 



%Throughout Allocation, the domain manager reacts to a 
%a \textit{$\mu$-service acquired} event --- indicating that the function(s) and dependencies have been fetched, and that the $\mu$-service is ready to be deployed ---  
%%The domain manager must react 
%by including this $\mu$-service in its self-management loop handling allocation. 
%%\textbf{THIS SELF-MANAGEMENT LOOP IS NOT WELL INTRODUCED. IT KIND OF DROPS OUT OF NOWHERE} 
%Also, to mitigate cold starts, the manager should react to a \textit{client arrived} event by anticipating Allocation for each identified $\mu$-service, if resources are available. 
%Finally, the manager should take into account a \textit{$\mu$-service requested} by updating the corresponding arrival rate metric. \textbf{I DON"T UNDERSTAND WHAT YOU MEAN HERE.}



%Accordingly, the AR and other low-priority applications could have to rely on $\mu$-services from their own mobile domain or a cloud domain.


%From the client's viewpoint, 

The fluctuations in the availability and service latency are handled by clients with the dynamic selection of the domain alternative that best satisfies the client requirements. Analogously to the provider-side Allocation, the mobile middleware realizes this activity by means of a self-management loop~\cite{kephart2003vision} for each $\mu$-service consumed by the client application.

To better express the client-side Allocation goal, let's extend the previous formulation by considering a continuum application $C_a$ that relies on the set of $\mu$-services $S_a = \{s_{a,i} \mid i = 1,2,...,I_a\}$, and the set of disjoint continuum domains $D = \{d_p \mid p = 1,2,...,P\}$ perceived by the client.
%, including the mobile domain. 
Each domain $d_p \in D$ provides a set of $\mu$-services $S_{p} = \{s_{p,j} \mid j =  1,2,..., J_p\}$. For each $s_{a,i} \in S_a$, there is at least one domain providing that $\mu$-service, that is, $\forall s_{a,i} \in S_a, \exists\ s_{p,j} \in \bigcup_{p=1}^{P} S_p \wedge s_{p,j} = s_{a,i}$. 

Now let's consider that each $s_{a,i} \in S_a$ is bound to a set of QoS requirements $QoS_a = \{q_{a,u} \mid u = 0, 1, ..., U_a\}$ and that each $q_{a,u} \in QoS_a$ is represented by a tuple $(ct_{a,u}, w_{a,u})$ respectively defining a \textit{constraint} (e.g. $service\ latency \le 300ms$) and a \textit{weight} for that attribute, with $w_u \in 0 \le w_u \le 1 \wedge \mathbb{R}$. For each $q_{a,u} \in QoS_a$, $actual_{p,a,u}$ defines the \textit{value} for that QoS attribute as perceived by the client. It follows that, for each $s_{a,i} \in S_a$, the aim of the \textit{mobile middleware} is to select the domain $d_p \in D$ 
%best satisfying the set of attributes in $QoS_o$, i.e., 
that maximizes the utility function $U_a(p) = \sum_{u=1}^{U_a} w_{a,u} * actual_{p,a,u}$, provided that $\forall q_{a,u} \in QoS_a, actual_{p,a,u} \vdash ct_{a,u}$, i.e., that QoS constraints are satisfied.

Throughout the self-management loop for each $s_{a,i} \in S_a$, the middleware handles a \textit{domain acquired (lost)} event --- indicating the agreement (denial) of a domain in providing a given $\mu$-service --- by including (disregarding) such domain. At each loop iteration, the mobile middleware \textit{monitors} the actual service latency ($actual_{p,a,u}$) from the list of \textit{capable domains} ($D_{p,i}$), as well as its own \textit{battery level}. Then, given the outcome of a multi-attribute analysis encompassing \textit{service latency} and \textit{battery consumption}, the middleware decides for either keeping the current domain or triggering a \textit{domain change} event in case a better alternative is found. A detailed implementation of the client-side self-management loop can be found in Sec.~\ref{sec:implementation}.

  %Conversely, a \textit{domain lost} event indicates a domain can no longer provide a $\mu$-service. The middleware must react by disregarding this domain in its self-management loop.



%the domain manager deals with the following events:
%{\small
%	\begin{itemize}[noitemsep,topsep=4pt]
%		
%		\item \textbf{$\mu$-service acquired:} indicates that function(s) and dependencies have been fetched and the $\mu$-service is ready to be deployed. The domain manager must react by including this $\mu$-service in its self-management loop handling Allocation.
%		
%		\item \textbf{Client arrived:} indicates the arrival of a client from a given $\mu$-service. To mitigate cold start, the manager should anticipate Allocation upon availability of resources.
%		
%		\item \textbf{$\mu$-service requested}: as defined in Section~\ref{sec:A3-E-engagement}. It should be taken into account by by the self-management loop handling Allocation with the increase of arrival rate ($\lambda_j$).
%		
%	\end{itemize}
%}%


%Traditionally, cloud domains employ automated scaling mechanisms in which virtual machines and container instances are (de)allocated on demand. More recently, cloud-based FaaS platforms (e.g., Amazon Lambda, Google Cloud Functions) extend these mechanisms to stateless functions. The later represent an extreme type of allocation in which no pre-allocation of resources is needed and functions are executed by a shared runtime platform. 

%To realize this activity, the domain manager exploits a self-management control loop~\cite{kephart2003vision} (see Figure~\ref{fig:service-allocation-loop}) in which the $\mu$-services are instantiated according to: (i) a monitored QoS (e.g., the latency with each domain), (ii) a SLA, and (iii) the availability of the computational resources. 
%Once , the DSM informs the client whether the $\mu$-services can be considered ``acquired'' or not.
%For instance, in a centralized implementation, the DSM orchestrates the placement of functions to containers distributed along multiple servers.


%TODO the SLA part is too vague, we must be more assertive regarding priority
%While in cloud domains scalability is virtually unlimited, in finely distributed edge domains scalability needs to be prioritized to favor applications with more demanding requirements. For instance, edge providers could support two types of SLAs: one for critical applications requiring high availability, and another for non-critical applications that may cope with lower degrees of availability.  

%The first type could be achieved with the pre-allocation of resources to these services, whilst the latter could rely on the opportunistic allocation of services upon demand and availability of resources. 
%In the scenario introduced in Section~\ref{sec:continuum}, the AV application should have a higher priority with respect to non-critical applications such as AR applications for tourists~\cite{GarrigaMendonca2017}. In this case the edge $\mu$-services might become unavailable to the AR applications, for example during rush hour. In that case the AR and other low-priority applications would have to rely on $\mu$-services being run in the mobile domain, or in a cloud domain.

%The specific algorithms for the placement of services among the domain's resources that should be employed at the analysis phase are out of the scope of this paper. Nonetheless, recent works~\cite{} have addressed this challenge in the context of a continuum formed by edge and cloud datacenters. 

%Given the state of different domains perceived by a client, the mobile middleware must decide which domain is responsible for each $\mu$-service consumed by the application. 







%
%{\small
%	\begin{itemize}[noitemsep,topsep=4pt]
%		
%		\item \textbf{Domain acquired:} indicates the agreement of a domain in providing a given $\mu$-service. The mobile middleware must react by including this domain in its self-management loop.	
%		
%		\item \textbf{Domain lost:} indicates a domain can no longer provide a given $\mu$-service. The mobile middleware must react by removing this domain from its self-management loop.
%		
%	\end{itemize}
%}%



%, i.e., it models the computation placement along the client's perception of the continuum. 
%This decision should consider a list of available domains providing services requested by the client application with accompanying QoS attributes. Accordingly, whereas the domains should take care of intra-domain allocation through service placement, the clients are responsible for the inter-domain allocation through service selection.

%Analogously to the domain-side, the CSM manages allocation with a self-management loop , this time by checking QoS levels of services from each available domain and deciding for the alternative that best satisfies the client's requirements. 

%This sub-process is the main client-side activity required for the realization of the continuum, as it allows clients to seamlessly alternate among different continuum domains according to the context. 

%TODO [Danilo] check the consistency of the usage of the running example in this Section
%If we go back to our running example, in the absence of appropriate edge domains, the low-priority AR applications would need to choose between their local mobile domain and the cloud domain. If the application's requirements favor low-battery consumption, the cloud domain will be chosen for allocation. Otherwise, if low latency is the most important QoS metric, the local mobile domain will be chosen. As the number of requirements grows, a multi-objective optimization algorithm may be employed to decide among alternative domains.


%, upon unavailability of edge domains providing services with low latency, the AR application previously introduced would have to choose among mobile or cloud domain. If the application requirements prioritizes low battery consumption (e.g., because battery level is low), it should opt for the cloud domain. Otherwise, if low latency is the priority requirement, it should opt for the cloud domain. 



%The allocation phase has the following purposes: 1) to enable the efficient (Req. \textbf{R1.1}) and automated (Req. \textbf{R3.1}) allocation of domains' computational resources; and to enable clients to choose the best candidate among different available domains (Req. \textbf{R2.1}).

\subsection{Engagement}\label{sec:A3-E-engagement}

\textit{Engagement} models the actual provisioning of a continuum $\mu$-service by a domain after its successful acquisition and allocation.
%: at the beginning of this phase, the continuum $\mu$-service has been \textit{allocated} by a domain, which in turn has been previously \textit{selected} by the client. 
Throughout Engagement, and as long as the client-domain interaction persists, the client is able to engage with that domain by means of invocations to provided $\mu$-services. 
%the mobile middleware proxies \textit{C-request} events triggered by a continuum application to the domain selected by the client-side Allocation.

Remote domains (i.e., cloud and edge) are engaged through distributed protocols (e.g., HTTP requests or WebSockets). To enforce a common interface between the mobile middleware and heterogeneous domains, the mobile domain is engaged by means of system-level events.
%also expose its functionality as local services decoupled from the client application.

During Engagement, the domain manager handles \textit{$\mu$-service request} signals by placing it into one $\mu$-service instance after a \textit{load balancing} strategy. Reflecting Allocation decisions, the manager reacts to a \textit{$\mu$-service deallocated} event 
indicating that a $\mu$-service has become unavailable 
%The domain manager reacts 
by queuing subsequent requests and, in case of a service latency violations, by sending a \textit{$\mu$-service response} signal with an error code. Conversely, a \textit{$\mu$-service allocated} event indicates the recovery of a given $\mu$-service, which is handled with the processing of queued and subsequent requests. 

%indicates the arrival of a request for a specific $\mu$-service. The manager must handle the event with the placement of the request to a service instance after a \textit{load balancing} strategy.

%the domain manager deals with the following events:
%
%{\small
%	\begin{itemize}[noitemsep,topsep=4pt]
%		
%		\item \textbf{$\mu$-service deallocated:} indicates the unavailability of a given $\mu$-service. The manager must react by queuing or sending a \textit{request response} signal with error code to subsequent requests.
%		
%		\item \textbf{$\mu$-service allocated:} indicates the availability of a given $\mu$-service. The manager must react by resuming the processing of queued and subsequent requests.	
%		
%		\item \textbf{$\mu$-service requested:} indicates the arrival of a request for a specific $\mu$-service. The manager must handle the event with the placement of the request to a service instance after a \textit{load balancing} strategy.
%	\end{itemize}
%}%

From the client's viewpoint, a \textit{C-request arrived} indicates the client application has sent a new request to a continuum $\mu$-service. The event contains the target $\mu$-service name along with any parameters for its function; the middleware handles it by invoking (\textit{$\mu$-service request}) the $\mu$-service from the currently selected domain. Upon arrival of a \textit{$\mu$-service response}, the middleware proceeds with the triggering of a \textit{C-request reply} event to be handled by the client application.  

Throughout Engagement, the mobile middleware listens for \textit{domain changed} events indicating which domain to invocate. In the particular case in which no domain is available for that specific $\mu$-service,
%a \textit{domain absent} event indicates no domain is available for that specific $\mu$-service. 
the middleware reacts by queuing subsequent C-requests until a new \textit{domain changed} event confirms a new domain or, in case of timeout, by triggering a \textit{C-request reply} with an error. 

%In turn, a \textit{domain changed} event indicates a new domain selection for a specific $\mu$-service. The middleware must handle it by resuming the invocation of any queued and subsequent C-requests to that domain.

\begin{figure}[tbp]
	\includegraphics[width=0.95\textwidth]{figs/A3-E-instance-events}
%	\setlength{\belowcaptionskip}{-10pt}
	\caption{A timeline of events from the Running Example scenario (Sec.~\ref{sub:example}). Labels: \textit{domain identification} ($DI$); \textit{$\mu$-service identified} ($\mu I$); \textit{$\mu$-service acquired} ($\mu AQ$); \textit{$\mu$-service allocated} ($\mu AL$); \textit{domain changed} ($DC$); \textit{C-request arrived} ($CR$'); \textit{$\mu$-service request} ($\mu R$'); textit{$\mu$-service identified} ($\mu R$'') \textit{C-request served} ($CR$''); \textit{domain lost} ($DL$).}
	\label{fig:A3-E-instance-events}
\end{figure}

Figure~\ref{fig:A3-E-instance-events} depicts a timeline of events from our Running Example scenario. The timeline starts with our user initializing the AR after entering the touristic area. The mobile middleware starts with the application and receives a \textit{domain identification} ($DI$) from its mobile domain, to be replied with a \textit{client identification} ($CI$). Following the $\mu$-service identification ($\mu I$), the middleware triggers a \textit{$\mu$-service allocated} ($\mu AL$) once the corresponding functions have been registered. After selecting this domain, the middleware triggers a \textit{domain changed} ($DC$), which allows subsequent \textit{C-request} ($CR$'') events to be handled locally. As our user's device enters a base station area (BSA) featuring a mobile-edge domain, the middleware receives a \textit{domain identification} ($DI$) and repeats the previous handshake procedure. To prevent battery drain, the self-management loop decides for the mobile-edge, triggering a $DC$ once the $\mu AL$ signal arrives. After a long period of engagement with that domain, our user enters the AV featuring a local-edge domain. As this is a first contact with the AR, this domain goes through Acquisition, whose completion is indicated by a \textit{$\mu$-service acquired} ($\mu AQ$). Due to a change of network, the connection with the mobile-edge is lost ($DL$). Preventing service interruption, the middleware momentarily switches back to its mobile domain until a $\mu AL$ signal arrives from the local-edge. Upon a \textit{domain confirmed} event (omitted), it switches domain ($DC$). 

%
%The mobile middleware deals with the following events:
%
%{\small
%	\begin{itemize}[noitemsep,topsep=4pt]
%		
%		\item \textbf{C-Request arrived:} indicates the client application has sent a new request to a continuum $\mu$-service. The event contains the target $\mu$-service reference along with any parameters. The middleware must handle it by invoking the $\mu$-service from the currently selected domain.
%		
%		\item \textbf{Request served:} indicates the arrival of a response from a domain for an invoked service. The middleware must handle it with the triggering of a \textit{C-Request served} event to be handled by the client application.
%		
%		%\item \textbf{C-Request served:} indicates a given C-request has been processed. It contains the original $\mu$-service reference along with any return value(s). The client application is responsible for handling the event.	
%		
%		\item \textbf{Domain changed:} indicates a domain have been selected for a specific $\mu$-service. The middleware must handle it by resuming the invocation of any queued and subsequent C-requests to that domain.
%		
%		\item \textbf{Domain absent:} indicates no domain is available for that specific $\mu$-service. The middleware must react by queuing subsequent C-requests and, in case of latency violation, firing a \textit{C-request failed} event.
%		
%	\end{itemize}
%}%

%TODO [Danilo] requirements must be passed by the application before, otherwise the domain selection would need to happen after the request has been fired
%It also contains continuum requirements that must be taken into account by the middleware in the decision of which 

%Two types of event dictate the end of an engagement: i) the client makes no further requests after a time interval; ii) the client selects another domain; and iii) the domain manager requires the deallocation of the service instance. 

%In all three cases, resources become available in the domain. In the latter case, the client is forced to select another domain.


%In this phase the request has already been provisioned by one or more domains and the client-side middleware (CSM) has already selected a specific domain to make the request. 

%handled and parsed by the client-side middleware (CSM), and . 


%Also, one or more domains must have setup and allocated the requested service for execution and the CSM must have selected a specific domain among all providing the same service. Finally, client's request are sent, processed, received, and returned to the application.

%Current FaaS providers allow functions to be exposed as REST services. The same applies to open source platforms implementing the FaaS model. Finally, different approaches may be used to expose local computation as services in mobile platforms like Android and iOS.

%As an exception, computation provided by mobile devices can be accessed by means of local calls to functions executed by the mobile platform.

%\input{sections/policies}


%
%\subsection{Reference Architecture}
%
%\begin{figure}[tbp]
%	\includegraphics[width=.95\textwidth]{figs/A3-E-reference-architecture}
%	\caption{A3-E architecture in Mobile Devices and edge domains}
%	\label{fig:reference-architecture}
%	\end{figure}
